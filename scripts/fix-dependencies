#!/bin/bash
#
# Copyright 2016-2017 the Bayou Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>
#
# Derives module dependencies for the given `package.json`, by iterating over
# local dependencies. This outputs a replacement `package.json`.

# Set `progName` to the program name, `progDir` to its directory, and `baseDir`
# to `progDir`'s directory. Follows symlinks.
function init-prog {
    local newp p="$0"

    while newp="$(readlink "$p")"; do
    [[ ${newp} =~ ^/ ]] && p="${newp}" || p="$(dirname "$p")/${newp}"
    done

    progName="${p##*/}"
    progDir="$(cd "$(dirname "$p")"; /bin/pwd -P)"
    baseDir="$(cd "${progDir}/.."; /bin/pwd -P)"
}
init-prog


#
# Argument parsing
#

# Output file.
outFile='/dev/stdout'

# Include local module dependencies?
includeLocalModules=1

# Error during argument processing?
argError=0

# Need help?
showHelp=0

while (( $# != 0 )); do
    opt="$1"
    if [[ ${opt} == '--' ]]; then
        shift
        break
    elif [[    ${opt} == '--help'
            || ${opt} == '-h' ]]; then
        showHelp=1
    elif [[ ${opt} =~ ^--out=(.*) ]]; then
        outFile="${BASH_REMATCH[1]}"
    elif [[ ${opt} == --no-locals ]]; then
        includeLocalModules=0
    elif [[ ${opt} =~ ^- ]]; then
        echo "Unknown option: ${opt}" 1>&2
        argError=1
        break
    else
        break
    fi
    shift
done
unset opt

if (( $# != 1 )); then
    argError=1
else
    inputFile="$1"
fi

if (( ${showHelp} || ${argError} )); then
    echo 'Usage:'
    echo ''
    echo "${progName} [--out=<path>] <path/to/package.json>"
    echo '  Derives local dependencies.'
    echo '  --out=<file>  Where to store the output.'
    echo '  --no-locals   Do not emit local module dependencies in the output.'
    echo '                (But do include the regular modules that the local'
    echo '                modules depend on.)'
    echo ''
    echo "${progName} [--help | -h]"
    echo "  Display this message."
    exit ${argError}
fi


#
# Main script
#

# Find all of the local modules referenced by this package, and all of _their_
# referenced local modules, etc. This uses a work queue arrangement where we
# start with the main input as the to-be-processed queue.
unprocessed=("${inputFile}")
localDeps=()
regularDeps=()
while (( ${#unprocessed[@]} != 0 )); do
    oneDep="${unprocessed[0]}"
    unprocessed=("${unprocessed[@]:1}") # Delete first element.

    already=0
    for f in "${localDeps[@]}"; do
        if [[ ${f} == ${oneDep} ]]; then
            already=1
            break
        fi
    done

    if (( ${already} )); then
        # We already processed this one.
        continue
    fi

    localDeps+=("${oneDep}")

    # Fluff it into a full path if just a simple name. This is the case for all
    # dependencies but the original input file.
    if [[ !(${oneDep} =~ '/') && ! -r ${oneDep} ]]; then
        oneDep="${baseDir}/local-modules/${oneDep}/package.json"
    fi

    if [[ ! -r "${oneDep}" ]]; then
        echo "Not readable: ${oneDep}" 1>&2
        exit 1
    fi

    # Extract local dependencies.
    unprocessed+=($(
        jq --raw-output \
            '(.dependencies // {}) | to_entries | .[] | select(.value == "local") | .key' \
            "${oneDep}"
    ))

    # Extract regular dependencies.
    regularDeps+=($(
        jq --raw-output \
            '(.dependencies // {}) | to_entries | .[] | select(.value != "local") | .key + "@" + .value' \
            "${oneDep}"
    ))
done

# Remove the first "local dep" because that's the original input file.
localDeps=("${localDeps[@]:1}")

# Verify that there aren't two (or more) different versions listed for any
# single regular dependency. We do this by constructing and evaluating a `jq`
# program that emits a complaint when there's trouble.
problem="$(
    (
        echo '{}'

        for d in "${regularDeps[@]}"; do
            [[ ${d} =~ ^(.*)@([^@]*)$ ]]
            name="${BASH_REMATCH[1]}"
            spec="${BASH_REMATCH[2]}"
            nameq='"'"${name}"'"'
            specq='"'"${spec}"'"'

            echo "| if (.dependencies.${nameq} // ${specq}) == ${specq}"
            echo "then .dependencies.${nameq} = ${specq}"
            echo 'else .error = (.error // "") + "Differing versions of " +' "${nameq}" '+ ".\n"'
            echo "end"
        done

        echo '| if (.error) then .error else "" end'
    ) | jq -f /dev/stdin --null-input --raw-output
)"
if [[ ${problem} != '' ]]; then
    echo "${problem}" 1>&2
    exit 1
fi


# Construct and evaluate a `jq` program to perform all the edits.
(
    echo '.'

    for d in "${localDeps[@]}"; do
        nameq='"'"${d}"'"'
        specq='"'"../local-modules/${d}"'"'

        if (( ${includeLocalModules} )); then
            echo "| .dependencies.${nameq} = ${specq}"
        else
            echo "| del(.dependencies.${nameq})"
        fi
    done

    for d in "${regularDeps[@]}"; do
        [[ ${d} =~ ^(.*)@([^@]*)$ ]]
        name="${BASH_REMATCH[1]}"
        spec="${BASH_REMATCH[2]}"
        nameq='"'"${name}"'"'
        specq='"'"${spec}"'"'

        echo "| .dependencies.${nameq} = ${specq}"
    done
) | jq -f /dev/stdin "${inputFile}" > "${outFile}"

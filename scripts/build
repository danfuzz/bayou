#!/bin/bash
#
# Copyright 2016-2017 the Bayou Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>
#
# Builds the product. See `--help` for details.
#

# Set `progName` to the program name, `progDir` to its directory, and `baseDir`
# to `progDir`'s directory. Follows symlinks.
function init-prog {
    local newp p="$0"

    while newp="$(readlink "$p")"; do
        [[ ${newp} =~ ^/ ]] && p="${newp}" || p="$(dirname "$p")/${newp}"
    done

    progName="${p##*/}"
    progDir="$(cd "$(dirname "$p")"; /bin/pwd -P)"
    baseDir="$(cd "${progDir}/.."; /bin/pwd -P)"
}
init-prog


#
# Argument parsing
#

# Error during argument processing?
argError=0

# Need help?
showHelp=0

# Boxed dependency directory, if any.
boxDir=''

# Try building a client bundle?
clientBundle=0

# Overlay source directory, if any.
overlayDir=''

# Run server tests?
serverTest=0

# Options to pass to `out-dir-setup`.
outOpts=()

while (( $# != 0 )); do
    opt="$1"
    if [[ ${opt} == '--' ]]; then
        shift
        break
    elif [[ ${opt} =~ ^--boxes=(.*) ]]; then
        boxDir="${BASH_REMATCH[1]}"
    elif [[ ${opt} == '--clean' ]]; then
        outOpts+=("${opt}")
    elif [[ ${opt} == '--client-bundle' ]]; then
        clientBundle=1
    elif [[    ${opt} == '--help'
            || ${opt} == '-h' ]]; then
        showHelp=1
    elif [[ ${opt} =~ ^--out=(.*) ]]; then
        outOpts+=("${opt}")
    elif [[ ${opt} =~ ^--overlay=(.*) ]]; then
        overlayDir="${BASH_REMATCH[1]}"
    elif [[ ${opt} == '--server-test' ]]; then
        serverTest=1
    elif [[ ${opt} =~ ^- ]]; then
        echo "Unknown option: ${opt}" 1>&2
        argError=1
        break
    else
        break
    fi
    shift
done
unset opt

if (( ${showHelp} || ${argError} )); then
    echo 'Usage:'
    echo ''
    echo "${progName} [<opt> ...]"
    echo '  Build the project.'
    echo ''
    echo '  --boxes=<dir>'
    echo '    Find boxed dependencies in directory <dir>.'
    echo '  --clean'
    echo '    Start from a clean build.'
    echo '  --client-bundle'
    echo '    On successful build, also try building a client bundle.'
    echo '  --out=<dir>'
    echo '    Place output in directory <dir>.'
    echo '  --overlay=<dir>'
    echo '    Find overlay source in directory <dir>.'
    echo '  --server-test'
    echo '    On successful build, also try running the server tests.'
    echo ''
    echo "${progName} [--help | -h]"
    echo '  Display this message.'
    exit ${argError}
fi


#
# Helper functions
#

# The name for source mapping files.
sourceMapName='source-map.txt'

# Helper for `check-environment-dependencies` which validates one dependency.
function check-dependency {
    local name="$1"
    local versionCmd="$2"
    local match="$3"

    # Extract just the command name, and verify that it exists at all.

    local cmdName=''
    if [[ ${versionCmd} =~ ^([^ ]+) ]]; then
        cmdName="${BASH_REMATCH[1]}"
    else
        # **Note:* This indicates a bug in this script, not a problem with the
        # environment.
        echo "Could not determine commmand name for ${name}." 1>&2
        exit 1
    fi

    if ! which "${cmdName}" >/dev/null 2>&1; then
        echo "Missing required command for ${name}: ${cmdName}" 1>&2
        exit 1
    fi

    local version="$(${versionCmd} 2>&1)"
    if ! grep -q -e "${match}" <<< "${version}"; then
        echo "Unsupported version of ${name}: ${version}" 1>&2
        exit 1
    fi
}

# Checks the versions of our various expected-installed dependencies, notably
# including Node and npm.
function check-environment-dependencies {
    check-dependency 'Node' 'node --version' '^v[678]\.'
    check-dependency 'npm' 'npm --version' '^[34]\.'
    check-dependency 'jq' 'jq --version' '^jq-1\.'
    check-dependency 'rsync' 'rsync --version' '.' # No actual version check.
}

# Sets up the output directory, including cleaning it out or creating it, as
# necessary.
function set-up-out {
    outDir="$(${progDir}/lib/out-dir-setup "${outOpts[@]}")"
    if [[ $? != 0 ]]; then
        return 1
    fi
}

# Gets a list of all the local module names. The output is a series of
# lines, one per module.
function local-module-names {
    (
        find "${baseDir}/local-modules" -mindepth 1 -maxdepth 1 -type d
        if [[ ${overlayDir} != '' && -e "${overlayDir}/local-modules" ]]; then
            find "${overlayDir}/local-modules" -mindepth 1 -maxdepth 1 -type d
        fi
    ) \
        | sed -e 's!.*\/!!g' \
        | sort -u
}

# Adds a new directory mapping to the build info file. This includes handling
# an overlay if it exists.
function add-directory-mapping {
    local fromDir="$1"
    local toDir="$2"
    local dirInfoFile="${outDir}/${toDir}/${sourceMapName}"

    mkdir -p "$(dirname "${dirInfoFile}")"

    (
        # Note: Some directories _only_ exist in the overlay, so we check for
        # existence of it before adding it to the mapping.
        if [[ -e "${baseDir}/${fromDir}" ]]; then
            echo "${baseDir}/${fromDir}"
        fi

        if [[ ${overlayDir} != '' && -e "${overlayDir}/${fromDir}" ]]; then
            echo "${overlayDir}/${fromDir}"
        fi
    ) > "${dirInfoFile}"
}

# Adds new directory mappings to the build info file for each subdirectory of
# a source directory. This includes handling of overlays if they exist.
function add-subdirectory-mapping {
    local fromDir="$1"

    local names=($(
        (
            cd "${baseDir}/${fromDir}"
            find . -mindepth 1 -maxdepth 1 -type d | cut -c 3-
            if [[ (${overlayDir} != '') && -e "${overlayDir}/${fromDir}" ]]; then
                cd "${overlayDir}/${fromDir}"
                find . -mindepth 1 -maxdepth 1 -type d | cut -c 3-
            fi
        ) | sort -u
    ))

    local n
    for n in "${names[@]}"; do
        add-directory-mapping "${fromDir}/${n}" "${fromDir}/${n}"
    done
}

# Sets up the directory mappings from the source into the `out` directory.
function set-up-dir-mapping {
    # This is the sub-module that's holds the compiler (transpiler) used for
    # processing `server` files.
    add-directory-mapping 'compiler' 'compiler'

    # The `server` files ultimately go through an additional build step (hence
    # the change in directory name), though some of the files are used as-is.
    add-directory-mapping 'server' 'server-src'

    # The `client` files are used as-is by the server (because it serves the
    # static assets directly and also knows how to (re)build the JavaScript
    # bundle).
    add-directory-mapping 'client' 'client'

    # The `local-modules` get pulled into both `client` and `server` (as
    # required by dependencies). We make a mapping per subdirectory because it
    # is the subdirectories (and not the whole) that get pulled in.
    add-subdirectory-mapping 'local-modules'
}

# Copies the server and client source directories into `out`, including the
# overlay contents (if any).
function copy-sources {
    local mappings=($(
        cd "${outDir}"
        find . -name "${sourceMapName}" | cut -c 3-
    ))

    # For each mapping file, copy all of the specified source files, but don't
    # include directories that themselves have separately-specified maps; those
    # get handled in their own iterations of this loop.
    local mapFile dir excludes sources s delArg
    for mapFile in "${mappings[@]}"; do
        dir="$(dirname "${mapFile}")"

        excludes=($(
            # Exclude the source map files themselves.
            echo "--exclude=${sourceMapName}"

            # Exclude `node_modules` because those get created in the output
            # during the build, and we don't want to trample them.
            echo '--exclude=node_modules'

            # Exclude subdirectories that have maps.
            cd "${outDir}/${dir}"
            find . -mindepth 2 -name "${sourceMapName}" \
                -exec dirname '{}' ';' \
                | awk '{ printf("--exclude=/%s\n", substr($1, 3)); }'
        ))

        # Copy the first mapped directory entirely, including removing deleted
        # files. Then copy the rest -- the overlays -- without deleting. We use
        # `rsync` (even though this is a totally local operation) because it has
        # well-defined behavior when copying a tree on top of another tree and
        # also knows how to create directories as needed. Note that trailing
        # slashes on source directory names are significant to `rsync`
        # semantics.
        sources=($(cat "${outDir}/${mapFile}"))
        delArg=(--delete)
        for s in "${sources[@]}"; do
            rsync --archive "${delArg[@]}" \
                "${excludes[@]}" "${s}/" "${outDir}/${dir}"
            delArg=()
        done
    done
}

# Fixes the `package.json` files so that local modules are referred to by
# explicit path.
function fix-packages {
    local files=(
        "${outDir}/client/package.json"
        "${outDir}/server-src/package.json"
        $(find "${outDir}/local-modules" -name package.json)
    )

    local f unfixed
    for f in "${files[@]}"; do
        unfixed="$(dirname "${f}")/package-unfixed.json"
        if [[ -r "${unfixed}" ]]; then
            continue
        fi

        # This one hasn't yet been fixed with regard to local dependencies.
        # Fix it!
        cp "${f}" "${unfixed}"
        "${progDir}/lib/fix-dependencies" --out="${f}" \
            --overlay="${overlayDir}" "${unfixed}" \
            || return 1
    done
}

# Does an `npm install` in the given directory, or the equivalent by using
# boxed dependencies. After installation, applies local patches to installed
# modules.
function do-install {
    local dir="$1"
    local toDir="${outDir}/${dir}"

    cd "${toDir}"

    if [[ ${boxDir} == '' ]]; then
        # No boxed dependencies. Normal install.
        npm install --cache="${outDir}/npm-cache" || return 1
    else
        # We were asked to use the boxed dependencies.
        if [[ ${dir} =~ ^(.*)-src$ ]]; then
            # `server-src` gets built from the box `server.npmbox`.
            dir="${BASH_REMATCH[1]}"
        fi

        local boxFile="${boxDir}/${dir}.npmbox"

        if [[ ! -r ${boxFile} ]]; then
            echo 'Missing box file:' "${boxFile}" 1>&2
            return 1
        fi

        "${progDir}/lib/box-install" "${boxDir}/${dir}.npmbox" || return 1
    fi

    # We are somewhat at the mercy of what's published via npm, and in fact
    # some modules that we use occasionally have bugs in their published
    # versions. This script patches them in situ based on the contents of the
    # directory `etc/module-overlay`
    "${progDir}/lib/fix-modules" "${baseDir}/etc/module-overlay" "${toDir}"
}

# Builds the server code. This builds from `server-src` into `server`. The
# JS files in the former are treated as modern ECMAScript, which are processed
# by Babel.
function build-server {
    local fromDir="${outDir}/server-src"
    local toDir="${outDir}/server"

    # Find the `babel` script (provided by the `compiler` submodule).
    local compile="$(find "${outDir}/compiler" -name 'bayou-compile')"
    if [[ ${compile} == '' ]]; then
        echo 'Could not find compiler script.' 1>&2
        return 1
    fi

    # Do the initial npm(ish) installation.
    do-install server-src || return 1

    # Copy everything over to the final `server` directory. See above about
    # why we use `rsync`.
    rsync --archive --delete "${fromDir}/" "${toDir}"

    # Run Babel on all of the local source files, storing them next to the
    # imported and patched modules.

    # Process the main `server` directory.
    "${compile}" "${fromDir}" "${toDir}" || return 1

    # Process each of the local modules that are used by `server`.
    local name
    for name in $(local-module-names); do
        if [[ -d "${fromDir}/node_modules/${name}" ]]; then
            "${compile}" "${fromDir}/node_modules/${name}" \
                "${toDir}/node_modules/${name}" \
                || return 1
        fi
    done
}

# Builds the client code.
function build-client {
    do-install client || return 1
}

# Builds the compiler (transpiler) code.
function build-compiler {
    do-install compiler || return 1
}

# "Builds" the `bin` directory.
function build-bin {
    local toDir="${outDir}/bin"

    mkdir -p "${toDir}" || return 1

    # See comment above about why we use `rsync`.
    rsync --archive --delete --exclude='README.md' \
        "${baseDir}/etc/bin-src/" "${toDir}" \
        || return 1

    chmod a+x "${toDir}"/*
}

# Builds the product info file.
function build-product-info {
    local fileName='product-info.txt'
    local outFile="${outDir}/${fileName}"
    local inFile="${baseDir}/${fileName}"

    # Use the overlay file, if it exists.
    if [[ (${overlayDir} != '') && -e "${overlayDir}/${fileName}" ]]; then
        inFile="${overlayDir}/${fileName}"
    fi

    # The git info, if available.
    local commitInfo="$(
        git log -1 --pretty=format:"commit-id = '%H'%ncommit-date = '%ai'" \
            2>/dev/null \
        || (
            echo 'commit-id = unknown'
            echo 'commit-date = unknown'
        )
    )"

    # Combine the static info file from the source with the git info to produce
    # the final output.
    (
        cat "${inFile}"
        echo "${commitInfo}"
    ) > "${outFile}"
}


#
# Main script
#

set-up-out || exit 1

echo 'Building...'

if [[ (${boxDir} != '') && ("$(uname)" == 'Darwin') ]]; then
    echo ''
    echo 'NOTE: Building from boxed dependencies on macOS generally results in'
    echo '  complaints about an inability to build the `fsevents` module. This'
    echo '  is expected and will not prevent the product from running.'
    echo ''
fi

(
    check-environment-dependencies \
        && set-up-dir-mapping \
        && copy-sources \
        && fix-packages \
        && build-compiler \
        && build-client \
        && build-server \
        && build-bin \
        && build-product-info
) || exit 1

if (( ${clientBundle} )); then
    "${outDir}/bin/run" --client-bundle || exit 1
fi

if (( ${serverTest} )); then
    "${outDir}/bin/run" --server-test || exit 1
fi

echo 'Done!'

#!/bin/bash
#
# Copyright 2016-2017 the Bayou Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>
#
# Builds the product. See `--help` for details.
#

# Set `progName` to the program name, `progDir` to its directory, and `baseDir`
# to `progDir`'s directory. Follows symlinks.
function init-prog {
    local newp p="$0"

    while newp="$(readlink "$p")"; do
        [[ ${newp} =~ ^/ ]] && p="${newp}" || p="$(dirname "$p")/${newp}"
    done

    progName="${p##*/}"
    progDir="$(cd "$(dirname "$p")"; /bin/pwd -P)"
    baseDir="$(cd "${progDir}/.."; /bin/pwd -P)"
}
init-prog


#
# Argument parsing
#

# Error during argument processing?
argError=0

# Need help?
showHelp=0

# List of subprojects to build.
buildProjects=(compiler server client bin)

# Boxed dependency directory, if any.
boxDir=''

# Overlay source directory, if any.
overlayDir=''

# Options to pass to `out-dir-setup`.
outOpts=()

while (( $# != 0 )); do
    opt="$1"
    if [[ ${opt} == '--' ]]; then
        shift
        break
    elif [[ ${opt} =~ ^--boxes=(.*) ]]; then
        boxDir="${BASH_REMATCH[1]}"
    elif [[ ${opt} == '--clean' ]]; then
        outOpts+=("${opt}")
    elif [[    ${opt} == '--help'
            || ${opt} == '-h' ]]; then
        showHelp=1
    elif [[ ${opt} == '--linter' ]]; then
        buildProjects=(linter)
    elif [[ ${opt} =~ ^--out=(.*) ]]; then
        outOpts+=("${opt}")
    elif [[ ${opt} =~ ^--overlay=(.*) ]]; then
        overlayDir="${BASH_REMATCH[1]}"
    elif [[ ${opt} =~ ^- ]]; then
        echo "Unknown option: ${opt}" 1>&2
        argError=1
        break
    else
        break
    fi
    shift
done
unset opt

if (( ${showHelp} || ${argError} )); then
    echo 'Usage:'
    echo ''
    echo "${progName} [<opt> ...]"
    echo '  Build the project.'
    echo ''
    echo '  --boxes=<dir>'
    echo '    Find boxed dependencies in directory <dir>.'
    echo '  --clean'
    echo '    Start from a clean build.'
    echo '  --linter'
    echo '    Just build the linter.'
    echo '  --out=<dir>'
    echo '    Place output in directory <dir>.'
    echo '  --overlay=<dir>'
    echo '    Find overlay source in directory <dir>.'
    echo ''
    echo "${progName} [--help | -h]"
    echo '  Display this message.'
    exit ${argError}
fi


#
# Helper functions
#

# The name for source mapping files.
sourceMapName='source-map.txt'

# List of all mapping files.
mappingFiles=()

# Helper for `check-environment-dependencies` which validates one dependency.
function check-dependency {
    local name="$1"
    local versionCmd="$2"
    local match="$3"

    # Extract just the command name, and verify that it exists at all.

    local cmdName=''
    if [[ ${versionCmd} =~ ^([^ ]+) ]]; then
        cmdName="${BASH_REMATCH[1]}"
    else
        # **Note:* This indicates a bug in this script, not a problem with the
        # environment.
        echo "Could not determine commmand name for ${name}." 1>&2
        exit 1
    fi

    if ! which "${cmdName}" >/dev/null 2>&1; then
        echo "Missing required command for ${name}: ${cmdName}" 1>&2
        exit 1
    fi

    local version="$(${versionCmd} 2>&1)"
    if ! grep -q -e "${match}" <<< "${version}"; then
        echo "Unsupported version of ${name}: ${version}" 1>&2
        exit 1
    fi
}

# Checks the versions of our various expected-installed dependencies, notably
# including Node and npm.
function check-environment-dependencies {
    check-dependency 'Node' 'node --version' '^v[78]\.'
    check-dependency 'npm' 'npm --version' '^5\.'
    check-dependency 'jq' 'jq --version' '^jq-1\.'
    check-dependency 'rsync' 'rsync --version' '.' # No actual version check.
}

# Calls `rsync` so as to do an all-local (not actually remote) "archive" copy
# (preserving permissions, modtimes, etc.).
#
# **Note:** We use `rsync` and not `cp` (even though this is a totally local
# operation) because it has well-defined behavior when copying a tree on top of
# another tree and also knows how to create directories as needed.
#
# **Note:** Trailing slashes on source directory names are significant to
# `rsync`. This is salient at some of the use sites.
function rsync-archive {
    # **Note:** We turn off file-sameness checking, which is irrelevant for this
    # use and is furthermore counterproductive, in that it can cause a failure
    # to copy when two non-identical files happen to match in both size and
    # timestamp. (This has happened in practice. When running a build on a
    # freshly checked-out source tree, many many files have the same timestamps,
    # so only the file sizes come into play, and it's very easy to have a file
    # size coincidence.)
    rsync --archive --ignore-times "$@"
}

# Sets up the output directory, including cleaning it out or creating it, as
# necessary. This also sets `finalDir` to the directory under `outDir` for the
# final built product.
function set-up-out {
    outDir="$(${progDir}/lib/out-dir-setup "${outOpts[@]}")"
    if (( $? != 0 )); then
        return 1
    fi

    finalDir="${outDir}/final"
}

# Gets a list of all the local module names. The output is a series of
# lines, one per module.
function local-module-names {
    (
        find "${baseDir}/local-modules" -mindepth 1 -maxdepth 1 -type d
        if [[ ${overlayDir} != '' && -e "${overlayDir}/local-modules" ]]; then
            find "${overlayDir}/local-modules" -mindepth 1 -maxdepth 1 -type d
        fi
    ) \
        | sed -e 's!.*\/!!g' \
        | sort -u
}

# Adds a new directory mapping to the build info file. This includes handling
# an overlay if it exists.
function add-directory-mapping {
    local dirName="$1"
    local dirInfoFile="${outDir}/${dirName}/${sourceMapName}"

    mkdir -p "$(dirname "${dirInfoFile}")"

    (
        # Note: Some directories _only_ exist in the overlay, so we check for
        # existence of it before adding it to the mapping.
        if [[ -e "${baseDir}/${dirName}" ]]; then
            echo "${baseDir}/${dirName}"
        fi

        if [[ ${overlayDir} != '' && -e "${overlayDir}/${dirName}" ]]; then
            echo "${overlayDir}/${dirName}"
        fi
    ) > "${dirInfoFile}"

    mappingFiles+=("${dirInfoFile}")
}

# Adds new directory mappings to the build info file for each subdirectory of
# a source directory. This includes handling of overlays if they exist.
function add-subdirectory-mapping {
    local fromDir="$1"

    local names=($(
        (
            cd "${baseDir}/${fromDir}"
            find . -mindepth 1 -maxdepth 1 -type d | cut -c 3-
            if [[ (${overlayDir} != '') && -e "${overlayDir}/${fromDir}" ]]; then
                cd "${overlayDir}/${fromDir}"
                find . -mindepth 1 -maxdepth 1 -type d | cut -c 3-
            fi
        ) | sort -u
    ))

    local n
    for n in "${names[@]}"; do
        add-directory-mapping "${fromDir}/${n}" "${fromDir}/${n}"
    done
}

# Sets up the directory mappings from the source into the `out` directory.
function set-up-dir-mapping {
    add-directory-mapping 'compiler'
    add-directory-mapping 'linter'
    add-directory-mapping 'server'
    add-directory-mapping 'client'

    # The `local-modules` get pulled into `client`, `server`, and `compiler` (as
    # required by dependencies). We make a mapping per subdirectory because it
    # is the subdirectories  that get pulled in (not the entirety of the
    # `local-modules` directory).
    add-subdirectory-mapping 'local-modules'
}

# Copies the server and client source directories into `out`, including the
# overlay contents (if any).
function copy-sources {
    echo 'Copying sources...'

    # For each mapping file, copy all of the specified source files, but don't
    # include directories that themselves have separately-specified maps; those
    # get handled in their own iterations of this loop.
    local mapFile dir excludes sources s delArg
    for mapFile in "${mappingFiles[@]}"; do
        dir="$(dirname "${mapFile}")"

        excludes=($(
            # Exclude the source map files themselves.
            echo "--exclude=${sourceMapName}"

            # Exclude `node_modules` because those get created in the output
            # during the build, and we don't want to trample them.
            echo '--exclude=node_modules'

            # Exclude the copy we might have made of the original `package.json`
            # file, and the fixed versions. These are generated during the build
            # and shouldn't get copied over or erased.
            echo '--exclude=package-unfixed.json'
            echo '--exclude=package-fixed.json'
            echo '--exclude=package-npm.json'

            # Exclude subdirectories that have maps. We don't have to bother
            # mentioning `node_modules` subdirectories here because of the
            # earlier blanket exclusion.
            cd "${dir}"
            find . -mindepth 2 \
                '(' '!' -path '*/node_modules/*' ')' \
                -name "${sourceMapName}" \
                -exec dirname '{}' ';' \
                | awk '{ printf("--exclude=/%s\n", substr($1, 3)); }'
        ))

        # Copy the first mapped directory entirely, including removing deleted
        # files. Then copy the rest -- the overlays -- without deleting.
        sources=($(cat "${mapFile}"))
        delArg=(--delete)
        for s in "${sources[@]}"; do
            rsync-archive "${delArg[@]}" "${excludes[@]}" "${s}/" "${dir}"
            delArg=()
        done
    done

    echo 'Copying sources... done.'
}

# Does an `npm install` in the given directory, or the equivalent by using
# boxed dependencies. After installation, applies local patches to installed
# modules.
function do-install {
    local dir="$1"
    local toDir="${outDir}/${dir}"
    local npmDir="${toDir}/from-npm"
    local packageJson="${toDir}/package.json"
    local npmPackageJson="${toDir}/package-npm.json"

    # Integrates local module dependencies into this package. It copies the
    # required local modules and also rewrites the top-level `package.json` so
    # that it lists the transitive closure of external module dependencies.
    "${progDir}/lib/copy-local-dependencies" \
        --local-modules="${outDir}/local-modules" "${toDir}" \
    || return 1

    if [[ -r ${npmPackageJson} ]] \
           && cmp --quiet "${npmPackageJson}" "${packageJson}"; then
        # The `package.json` hasn't changed since we `npm install`ed, so we can
        # skip the rest of this function.
        echo "${dir}:" \
            'No change to external dependencies. Skipping `npm install`.'
        return
    fi

    echo "${dir}:" 'Installing external dependencies...'

    # This runs `npm install` in a new empty directory, because as of npm v5,
    # npm _really really_ wants to manage all modules under `node_modules`, and
    # in our case we have local modules which npm doesn't know about and
    # therefore wants to remove whenever we do `npm install`. **TODO:** Simplify
    # this back to just doing `npm install` in the main directory, should npm
    # ever gain a way to understand that there are some module directories that
    # it shouldn't touch. See <https://github.com/npm/npm/issues/18062>.

    rm -rf "${npmDir}"
    mkdir -p "${npmDir}"
    rsync-archive "${packageJson}" "${npmDir}/package.json"

    if [[ ${boxDir} == '' ]]; then
        # No boxed dependencies. Normal install.
        (cd "${npmDir}" && npm install --no-package-lock) || return 1
    else
        # We were asked to use the boxed dependencies.
        local boxFile="${boxDir}/${dir}.npmbox"

        if [[ ! -r ${boxFile} ]]; then
            echo 'Missing box file:' "${boxFile}" 1>&2
            return 1
        fi

        (cd "${npmDir}" \
            && "${progDir}/lib/box-install" "${boxDir}/${dir}.npmbox") \
        || return 1
    fi

    # We are somewhat at the mercy of what's published via npm, and in fact
    # some modules that we use occasionally have bugs in their published
    # versions. This script patches them in situ based on the contents of the
    # directory `etc/module-overlay`.
    "${progDir}/lib/fix-modules" "${baseDir}/etc/module-overlay" "${npmDir}" \
    || return 1

    # Move each of the directories that `npm` got for us into the subproject's
    # `node_modules`.
    #
    # **Note:** We don't just `mv` (or `rsync --delete`) the whole
    # `node_modules` directory, because we want to keep our local modules, and
    # if we don't `--delete` then we could end up with weird module amalgams in
    # cases where an external module got updated.

    echo "${dir}:" 'Moving external dependencies into place...'

    local d
    for d in $(cd "${npmDir}/node_modules"; /bin/ls -A); do
        (
            fromDir="${npmDir}/node_modules/${d}"
            toDir="${toDir}/node_modules/${d}"
            rm -rf "${toDir}" && mv "${fromDir}" "${toDir}"
        ) || return 1
    done

    rm -rf "${npmDir}" || return 1

    # Copy the `package.json` that we installed with, so we can compare it on
    # subsequent builds.
    rsync-archive "${packageJson}" "${npmPackageJson}" || return 1

    echo "${dir}:" 'External dependencies... done.'
}

# Builds the server code. This builds from `server` into `final/server`. The
# JS files in the former are treated as modern ECMAScript, which are processed
# by Babel.
function build-server {
    local fromDir="${outDir}/server"
    local toDir="${finalDir}/server"

    # Find the `babel` script (provided by the `compiler` submodule).
    local compile="$(find "${outDir}/compiler" -name 'bayou-compile')"
    if [[ ${compile} == '' ]]; then
        echo 'Could not find compiler script.' 1>&2
        return 1
    fi

    # Do the initial npm(ish) installation.
    do-install server || return 1

    # Run Babel on all of the local source files, storing them next to the
    # imported and patched modules.

    # Process the main `server` directory.
    "${compile}" "${fromDir}" "${toDir}" || return 1

    # Process each of the local modules that is used by `server`.
    local name
    for name in $(local-module-names); do
        if [[ -d "${fromDir}/node_modules/${name}" ]]; then
            "${compile}" "${fromDir}/node_modules/${name}" \
                "${toDir}/node_modules/${name}" \
                || return 1
        fi
    done

    # Copy everything else over to the final `server` directory as-is. We use
    # the `--update` option to avoid clobbering those Babel-compiled files we
    # just went through all the trouble to make.
    rsync-archive --delete --update "${fromDir}/" "${toDir}" || return 1
}

# Builds the client code.
function build-client {
    local toDir="${finalDir}/client"

    mkdir -p "${toDir}" || return 1
    do-install client || return 1

    # Copy the built result into the final output.
    rsync-archive --delete "${outDir}/client/" "${toDir}" \
    || return 1
}

# Builds the compiler (transpiler) code.
function build-compiler {
    do-install compiler || return 1
}

# Builds the code linter.
function build-linter {
    do-install linter || return 1
}

# "Builds" the `bin` directory.
function build-bin {
    local toDir="${finalDir}/bin"

    mkdir -p "${toDir}" || return 1

    rsync-archive --delete --exclude='README.md' \
        "${baseDir}/etc/bin-src/" "${toDir}" \
        || return 1

    chmod a+x "${toDir}"/*
}

# Builds the product info file.
function build-product-info {
    local fileName='product-info.txt'
    local outFile="${finalDir}/${fileName}"
    local inFile="${baseDir}/${fileName}"

    # Use the overlay file, if it exists.
    if [[ (${overlayDir} != '') && -e "${overlayDir}/${fileName}" ]]; then
        inFile="${overlayDir}/${fileName}"
    fi

    # The git info, if available.
    local commitInfo="$(
        git log -1 --pretty=format:"commit-id = '%H'%ncommit-date = '%ai'" \
            2>/dev/null \
        || (
            echo 'commit-id = unknown'
            echo 'commit-date = unknown'
        )
    )"

    mkdir -p "$(dirname "${outFile}")"

    # Combine the static info file from the source with the git info to produce
    # the final output.
    (
        cat "${inFile}"
        echo "${commitInfo}"
    ) > "${outFile}"
}


#
# Main script
#

set-up-out || exit 1

echo 'Building...'

if [[ (${boxDir} != '') && ("$(uname)" == 'Darwin') ]]; then
    echo ''
    echo 'NOTE: Building from boxed dependencies on macOS generally results in'
    echo '  complaints about an inability to build the `fsevents` module. This'
    echo '  is expected and will not prevent the product from running.'
    echo ''
fi

(
    check-environment-dependencies \
        && set-up-dir-mapping \
        && copy-sources \
        && build-product-info
) || exit 1

for proj in "${buildProjects[@]}"; do
    "build-${proj}" || exit 1
done

echo 'Done with build!'
